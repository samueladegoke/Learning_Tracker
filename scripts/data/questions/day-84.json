[
    {
        "question_type": "mcq",
        "text": "Which module is used to run external commands and scripts in Python?",
        "options": [
            "os.system",
            "subprocess",
            "shutil",
            "sys"
        ],
        "correct_index": 1,
        "difficulty": "easy",
        "topic_tag": "automation",
        "explanation": "The subprocess module is the recommended way to spawn new processes and connect to their input/output/error pipes."
    },
    {
        "question_type": "mcq",
        "text": "How do you copy a file including its metadata (like permissions) using shutil?",
        "options": [
            "shutil.copy()",
            "shutil.copy2()",
            "shutil.move()",
            "shutil.replicate()"
        ],
        "correct_index": 1,
        "difficulty": "medium",
        "topic_tag": "automation",
        "explanation": "shutil.copy2() is identical to shutil.copy(), but also attempts to preserve file metadata."
    },
    {
        "question_type": "mcq",
        "text": "What does subprocess.run(..., capture_output=True) do?",
        "options": [
            "Suppresses all output",
            "Saves the command output to a file",
            "Captures stdout and stderr in the return object",
            "Runs the command in the background"
        ],
        "correct_index": 2,
        "difficulty": "medium",
        "topic_tag": "automation",
        "explanation": "capture_output=True captures the standard output and standard error so you can access them via result.stdout and result.stderr."
    },
    {
        "question_type": "mcq",
        "text": "Which symbol represents 'one or more' in a regular expression (regex)?",
        "options": [
            "*",
            "+",
            "?",
            "$"
        ],
        "correct_index": 1,
        "difficulty": "easy",
        "topic_tag": "regex",
        "explanation": "The '+' quantifier matches 1 or more occurrences of the preceding element."
    },
    {
        "question_type": "mcq",
        "text": "In argparse, how do you define an optional argument that acts as a flag (True/False)?",
        "options": [
            "add_argument('--flag', type=bool)",
            "add_argument('--flag', action='store_true')",
            "add_argument('--flag', value='toggle')",
            "add_argument('--flag', mode='boolean')"
        ],
        "correct_index": 1,
        "difficulty": "medium",
        "topic_tag": "argparse",
        "explanation": "action='store_true' makes the argument optional and sets it to True if present, False otherwise."
    },
    {
        "question_type": "mcq",
        "text": "What is the result of re.findall(r'\\d+', 'Price: 123, Qty: 5')?",
        "options": [
            "['1', '2', '3', '5']",
            "['123', '5']",
            "['123']",
            "Error"
        ],
        "correct_index": 1,
        "difficulty": "medium",
        "topic_tag": "regex",
        "explanation": "\\d+ matches sequences of digits. re.findall returns all non-overlapping matches as a list of strings."
    },
    {
        "question_type": "mcq",
        "text": "How do you recursively delete a directory tree using shutil?",
        "options": [
            "shutil.delete()",
            "shutil.rmdir()",
            "shutil.rmtree()",
            "shutil.remove()"
        ],
        "correct_index": 2,
        "difficulty": "easy",
        "topic_tag": "automation",
        "explanation": "shutil.rmtree() deletes an entire directory tree; all contents must be removed for a directory to be deleted by os.rmdir."
    },
    {
        "question_type": "mcq",
        "text": "What does subprocess.check_call() do if the command returns a non-zero exit code?",
        "options": [
            "Ignores it",
            "Returns False",
            "Raises a CalledProcessError",
            "Prints a warning"
        ],
        "correct_index": 2,
        "difficulty": "hard",
        "topic_tag": "automation",
        "explanation": "check_call() raises CalledProcessError if the return code is non-zero, making it useful for strict script automation."
    },
    {
        "question_type": "mcq",
        "text": "Which regex pattern matches a valid email address structure (simplified)?",
        "options": [
            "r'.*@.*\\..*'",
            "r'[a-z]@[a-z]'",
            "r'email:.*'",
            "r'\\w@\\w'"
        ],
        "correct_index": 0,
        "difficulty": "medium",
        "topic_tag": "regex",
        "explanation": "r'.*@.*\\..*' is a very simplified pattern checking for anything, '@', anything, '.', and anything."
    },
    {
        "question_type": "mcq",
        "text": "What is the purpose of shutil.make_archive()?",
        "options": [
            "To backup the system",
            "To create a zip or tar file of a directory",
            "To save database snapshots",
            "To encrypt files"
        ],
        "correct_index": 1,
        "difficulty": "easy",
        "topic_tag": "automation",
        "explanation": "make_archive() creates an archive file (like zip or tar) from a base directory."
    },
    {
        "question_type": "mcq",
        "text": "How do you check if a regex match exists at the BEGINNING of a string?",
        "options": [
            "re.search()",
            "re.match()",
            "re.findall()",
            "re.start()"
        ],
        "correct_index": 1,
        "difficulty": "medium",
        "topic_tag": "regex",
        "explanation": "re.match() checks for a match only at the beginning of the string, while re.search() checks anywhere."
    },
    {
        "question_type": "mcq",
        "text": "In argparse, what does nargs='+' mean?",
        "options": [
            "The value must be a positive number",
            "One or more arguments are expected",
            "The argument is optional",
            "The argument must be a string"
        ],
        "correct_index": 1,
        "difficulty": "hard",
        "topic_tag": "argparse",
        "explanation": "nargs='+' gathers one or more command-line arguments into a list."
    },
    {
        "question_type": "coding",
        "text": "File Extension Filter\nWrite a function that returns a list of files from a provided list that match a certain extension using regex.",
        "starter_code": "import re\n\ndef filter_files(files, ext):\n    # Return only files ending with .ext (case insensitive)\n    # Example: filter_files(['a.txt', 'b.jpg'], 'txt') -> ['a.txt']\n    return []",
        "test_cases": "files = ['data.csv', 'image.PNG', 'script.py', 'backup.CSV']\nresult = filter_files(files, 'csv')\nassert len(result) == 2\nassert 'data.csv' in result\nassert 'backup.CSV' in result\nassert 'script.py' not in result",
        "difficulty": "hard",
        "topic_tag": "regex",
        "solution_code": "import re\n\ndef filter_files(files, ext):\n    pattern = re.compile(f'\\.{ext}$', re.IGNORECASE)\n    return [f for f in files if pattern.search(f)]",
        "explanation": "Use re.compile with re.IGNORECASE to handle different cases. The pattern '\\.ext$' ensures the extension is at the end of the string."
    },
    {
        "question_type": "coding",
        "text": "Command Formatter\nWrite a function that takes a command name and a dictionary of flags, and returns a list suitable for subprocess.run.",
        "starter_code": "def format_cmd(command, flags):\n    # Example: format_cmd('ls', {'l': True, 'a': True}) -> ['ls', '-l', '-a']\n    return []",
        "test_cases": "res = format_cmd('git', {'version': True})\nassert res == ['git', '--version']\nres2 = format_cmd('ls', {'l': True, 'a': True})\nassert 'ls' in res2\nassert '-l' in res2\nassert '-a' in res2",
        "difficulty": "medium",
        "topic_tag": "automation",
        "solution_code": "def format_cmd(command, flags):\n    cmd = [command]\n    for key, value in flags.items():\n        if value:\n            prefix = '-' if len(key) == 1 else '--'\n            cmd.append(f'{prefix}{key}')\n    return cmd",
        "explanation": "Construct a list starting with the command name. Iterate through flags; if the value is True, append the flag with '-' for single-letter keys or '--' for longer names."
    },
    {
        "question_type": "code-correction",
        "text": "The regex is supposed to find all email addresses, but it only finds the first one. Fix it.",
        "code": "import re\ntext = 'Contact: a@b.com, support@site.org'\nmatch = re.match(r'[\\w.]+@[\\w.]+', text)\nprint(match.group())",
        "options": [
            "Use re.findall() instead of re.match()",
            "Add a 'g' flag to re.match()",
            "Use re.search() in a loop",
            "Change the regex to end with '$'"
        ],
        "correct_index": 0,
        "difficulty": "medium",
        "topic_tag": "regex",
        "explanation": "re.match() and re.search() only return the first match. re.findall() returns a list of all matches found in the entire string."
    },
    {
        "question_type": "mcq",
        "text": "What is the correct way to capture both stdout and stderr from subprocess.run()?",
        "options": [
            "subprocess.run(cmd, capture_all=True)",
            "subprocess.run(cmd, capture_output=True)",
            "subprocess.run(cmd, get_output=True)",
            "subprocess.run(cmd, pipe=True)"
        ],
        "correct_index": 1,
        "difficulty": "easy",
        "topic_tag": "automation",
        "explanation": "capture_output=True is shorthand for stdout=PIPE, stderr=PIPE."
    },
    {
        "question_type": "mcq",
        "text": "Which re function returns a match object at the first location where the pattern matches?",
        "options": [
            "re.match()",
            "re.search()",
            "re.findall()",
            "re.split()"
        ],
        "correct_index": 1,
        "difficulty": "easy",
        "topic_tag": "regex",
        "explanation": "re.search() scans the entire string for the first match. re.match() only checks at the beginning."
    },
    {
        "question_type": "coding",
        "text": "Directory Size Calculator\nWrite a function that calculates the total size in bytes of all files in a directory (non-recursive).",
        "starter_code": "import os\n\ndef dir_size(path):\n    # Return total bytes of all files in path\n    return 0",
        "test_cases": "import os\nos.makedirs('/tmp/test_dir', exist_ok=True)\nwith open('/tmp/test_dir/a.txt', 'w') as f: f.write('hello')\nwith open('/tmp/test_dir/b.txt', 'w') as f: f.write('world!')\nresult = dir_size('/tmp/test_dir')\nassert result == 11, f'Expected 11, got {result}'",
        "difficulty": "medium",
        "topic_tag": "automation",
        "solution_code": "import os\n\ndef dir_size(path):\n    total = 0\n    for f in os.listdir(path):\n        fp = os.path.join(path, f)\n        if os.path.isfile(fp):\n            total += os.path.getsize(fp)\n    return total",
        "explanation": "Use os.listdir() to iterate, os.path.join() for full path, and os.path.getsize() for file size."
    },
    {
        "question_type": "coding",
        "text": "Phone Number Extractor\nWrite a function that extracts all phone numbers (format: XXX-XXX-XXXX) from a text string.",
        "starter_code": "import re\n\ndef extract_phones(text):\n    # Return list of phone numbers in XXX-XXX-XXXX format\n    return []",
        "test_cases": "text = 'Call 123-456-7890 or 987-654-3210 today!'\nresult = extract_phones(text)\nassert len(result) == 2\nassert '123-456-7890' in result\nassert '987-654-3210' in result",
        "difficulty": "medium",
        "topic_tag": "regex",
        "solution_code": "import re\n\ndef extract_phones(text):\n    pattern = r'\\d{3}-\\d{3}-\\d{4}'\n    return re.findall(pattern, text)",
        "explanation": "Use \\d{3} to match 3 digits, hyphen as literal, then \\d{4} for 4 digits."
    },
    {
        "question_type": "coding",
        "text": "Environment Variable Parser\nWrite a function that parses KEY=VALUE pairs from a list of strings into a dictionary.",
        "starter_code": "def parse_env(lines):\n    # Parse 'KEY=VALUE' strings into dict\n    return {}",
        "test_cases": "lines = ['DB_HOST=localhost', 'PORT=5432', 'DEBUG=true']\nresult = parse_env(lines)\nassert result['DB_HOST'] == 'localhost'\nassert result['PORT'] == '5432'\nassert result['DEBUG'] == 'true'",
        "difficulty": "easy",
        "topic_tag": "automation",
        "solution_code": "def parse_env(lines):\n    env = {}\n    for line in lines:\n        key, value = line.split('=', 1)\n        env[key] = value\n    return env",
        "explanation": "Split each line on '=' with maxsplit=1 to handle values containing '='."
    },
    {
        "question_type": "code-correction",
        "text": "The subprocess call hangs when reading large output. Fix it.",
        "code": "import subprocess\nresult = subprocess.run(['ls', '-la'], stdout=subprocess.PIPE)\noutput = result.stdout",
        "options": [
            "Add text=True to decode output as string",
            "Use capture_output=True instead",
            "Add timeout parameter to prevent hangs",
            "Change PIPE to DEVNULL"
        ],
        "correct_index": 2,
        "difficulty": "hard",
        "topic_tag": "automation",
        "explanation": "Adding timeout prevents indefinite blocking on commands that might hang."
    },
    {
        "question_type": "code-correction",
        "text": "The regex fails to match multi-line strings. Fix it.",
        "code": "import re\ntext = 'Line1\\nLine2\\nLine3'\nmatches = re.findall(r'^Line', text)",
        "options": [
            "Add re.MULTILINE flag",
            "Change ^ to \\n",
            "Use re.search() instead",
            "Remove the ^ anchor"
        ],
        "correct_index": 0,
        "difficulty": "medium",
        "topic_tag": "regex",
        "explanation": "re.MULTILINE makes ^ match at the start of each line, not just the string."
    },
    {
        "question_type": "code-correction",
        "text": "The shutil.copy() fails silently when destination exists. Fix it to raise an error.",
        "code": "import shutil\nshutil.copy('source.txt', 'dest.txt')",
        "options": [
            "Check if dest exists with os.path.exists() first and raise FileExistsError",
            "Use shutil.copy2() instead",
            "Add overwrite=False parameter",
            "Use shutil.move() instead"
        ],
        "correct_index": 0,
        "difficulty": "hard",
        "topic_tag": "automation",
        "explanation": "shutil.copy() overwrites silently. To prevent this, check existence first and raise explicitly."
    }
]