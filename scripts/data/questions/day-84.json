[
    {
        "question_type": "mcq",
        "text": "When representing a 3x3 Tic-Tac-Toe board as a 1D list of length 9, how do you calculate the 1D index from a row 'r' and column 'c' (where r,c are 0-2)?",
        "options": [
            "index = r + c",
            "index = (r * 3) + c",
            "index = (c * 3) + r",
            "index = r * c"
        ],
        "correct_index": 1,
        "difficulty": "medium",
        "topic_tag": "data-structures",
        "explanation": "To flatten a 2D coordinate into a 1D index, you multiply the row index by the width of the row (3) and add the column index."
    },
    {
        "question_type": "mcq",
        "text": "What is the primary benefit of using a Tuple of Tuples to store winning combinations like [(0,1,2), (3,4,5)...] in Python?",
        "options": [
            "Tuples are faster for mathematical calculations",
            "Immutability prevents accidental modification of game rules at runtime",
            "Tuples consume more memory which is better for modern systems",
            "Tuples allow for easy sorting of winning lines"
        ],
        "correct_index": 1,
        "difficulty": "medium",
        "topic_tag": "best-practices",
        "explanation": "Tuples are immutable. Storing game constants in a tuple ensures that the 'winning conditions' cannot be accidentally changed during game execution."
    },
    {
        "question_type": "mcq",
        "text": "In a professional game loop, why is it better to handle user input inside a 'while' loop with 'try/except' rather than a simple 'input()' call?",
        "options": [
            "To make the game run at 60 FPS",
            "To prevent the program from crashing if a user enters a non-integer character (like 'X' instead of '5')",
            "Because Python 3 requires try/except for all input",
            "To allow the user to quit the game faster"
        ],
        "correct_index": 1,
        "difficulty": "easy",
        "topic_tag": "robust-programming",
        "explanation": "User input is unpredictable. Robust CLI apps use try/except to catch ValueErrors when casting strings to integers."
    },
    {
        "question_type": "mcq",
        "text": "Which design pattern is most closely followed by the 'Listen -> Update -> Render' sequence in your Tic Tac Toe project?",
        "options": [
            "Singleton Pattern",
            "State Machine / Game Loop Pattern",
            "Factory Pattern",
            "Decorator Pattern"
        ],
        "correct_index": 1,
        "difficulty": "medium",
        "topic_tag": "architecture",
        "explanation": "The game loop is a standard engine pattern where the game transitions between states (Turn X, Turn O, Win, Draw) based on input."
    },
    {
        "question_type": "mcq",
        "text": "How do you check for a 'Draw' (Tie) in Tic Tac Toe efficiently if no winner is found?",
        "options": [
            "Count how many 'X's are on the board",
            "Check if ' ' (empty space) is not present in the board list/array",
            "Ask the players if they want to stop",
            "Wait for a 10-minute timer to expire"
        ],
        "correct_index": 1,
        "difficulty": "easy",
        "topic_tag": "game-logic",
        "explanation": "If the board is fully populated (no empty spaces) and no one has met the win condition, the game is a draw."
    },
    {
        "question_type": "mcq",
        "text": "If you wanted to build an 'Unbeatable' computer opponent for Tic Tac Toe, which algorithm would you implement?",
        "options": [
            "Binary Search",
            "Minimax Algorithm",
            "Bubble Sort",
            "Dijkstra's Algorithm"
        ],
        "correct_index": 1,
        "difficulty": "hard",
        "topic_tag": "ai-logic",
        "explanation": "Minimax is a decision-making algorithm used in game theory for two-player zero-sum games to find the optimal move."
    },
    {
        "question_type": "coding",
        "text": "Draw Detector\nWrite a function `is_draw(board)` that takes a list of 9 characters ('X', 'O', or ' ') and returns `True` if the board is full and there are no empty spaces left.",
        "starter_code": "def is_draw(board):\n    # TODO: Return True if no ' ' remains in the list\n    pass",
        "solution_code": "def is_draw(board):\n    return \" \" not in board",
        "test_cases": "assert is_draw(['X', 'O', 'X', 'O', 'X', 'O', 'O', 'X', 'O']) == True\nassert is_draw(['X', ' ', 'X', 'O', 'X', 'O', 'O', 'X', 'O']) == False",
        "difficulty": "easy",
        "topic_tag": "game-logic",
        "explanation": "The simplest way to check if a list is full in this context is to check for the absence of the placeholder space character."
    },
    {
        "question_type": "coding",
        "text": "Valid Move Checker\nImplement a function `valid_move(board, position)` that returns `True` if the position (0-8) is within range AND the corresponding cell on the board is currently empty (' ').",
        "starter_code": "def valid_move(board, position):\n    # position is 0-8\n    pass",
        "solution_code": "def valid_move(board, position):\n    if 0 <= position <= 8:\n        return board[position] == \" \"\n    return False",
        "test_cases": "board = ['X', ' ', 'O', ' ', ' ', ' ', ' ', ' ', ' ']\nassert valid_move(board, 1) == True\nassert valid_move(board, 0) == False\nassert valid_move(board, 10) == False",
        "difficulty": "medium",
        "topic_tag": "validation",
        "explanation": "Validation requires checking both the bounds of the list and the state of the specific index."
    },
    {
        "question_type": "coding",
        "text": "Diagonal Win Check\nWrite a function `check_diagonals(board)` that checks specifically the two diagonal win paths on a 3x3 board (indices 0,4,8 and 2,4,6). Return the player ('X' or 'O') if a win exists, otherwise None.",
        "starter_code": "def check_diagonals(board):\n    # indices: 0 1 2\n    #          3 4 5\n    #          6 7 8\n    pass",
        "solution_code": "def check_diagonals(board):\n    if board[0] == board[4] == board[8] != \" \":\n        return board[0]\n    if board[2] == board[4] == board[6] != \" \":\n        return board[2]\n    return None",
        "test_cases": "b1 = ['X', ' ', ' ', ' ', 'X', ' ', ' ', ' ', 'X']\nassert check_diagonals(b1) == 'X'\nb2 = [' ', ' ', 'O', ' ', 'O', ' ', 'O', ' ', ' ']\nassert check_diagonals(b2) == 'O'\nb3 = ['X', ' ', 'O', ' ', 'X', ' ', ' ', ' ', ' ']\nassert check_diagonals(b3) == None",
        "difficulty": "hard",
        "topic_tag": "game-logic",
        "explanation": "Explicitly checking the values at diagonal indices and ensuring they are not empty is a common logic branch in grid games."
    },
    {
        "question_type": "coding",
        "text": "Score Tracker\nWrite a function `update_score(scores, winner)` that takes a dictionary `scores = {'X': 0, 'O': 0, 'Draw': 0}` and increments the value for the winner. If winner is None, increment 'Draw'.",
        "starter_code": "def update_score(scores, winner):\n    # winner is 'X', 'O', or None\n    pass",
        "solution_code": "def update_score(scores, winner):\n    if winner:\n        scores[winner] += 1\n    else:\n        scores['Draw'] += 1\n    return scores",
        "test_cases": "s = {'X': 0, 'O': 0, 'Draw': 0}\nupdate_score(s, 'X')\nassert s['X'] == 1\nupdate_score(s, None)\nassert s['Draw'] == 1",
        "difficulty": "medium",
        "topic_tag": "state-management",
        "explanation": "Using a dictionary for scores is a scalable implementation pattern for portfolio projects."
    },
    {
        "question_type": "code-correction",
        "text": "The index calculation for a 2D-to-1D conversion is wrong. Fix it.",
        "code": "def get_index(row, col):\n    # Trying to convert 0-2 (row/col) to 0-8 index\n    return row + col * 3",
        "options": [
            "return row * 3 + col",
            "return col * 3 + row",
            "return (row + 1) * (col + 1) - 1",
            "return row + col"
        ],
        "correct_index": 0,
        "difficulty": "medium",
        "topic_tag": "index-math",
        "explanation": "In row-major order (standard for 2D arrays), row is the major axis, so multiply row by the width of the board (3) and add the column."
    },
    {
        "question_type": "code-correction",
        "text": "The player toggle logic is stuck on 'X'. Fix it so it alternates properly.",
        "code": "current_player = 'X'\ndef switch_player():\n    if current_player == 'X':\n        current_player = 'O'\n    else:\n        current_player = 'X'",
        "options": [
            "Use the global keyword: global current_player",
            "Change 'if' to 'while'",
            "Use return 'O' if player == 'X' else 'X'",
            "Use a for loop"
        ],
        "correct_index": 0,
        "difficulty": "medium",
        "topic_tag": "scope",
        "explanation": "To modify a global variable inside a function in Python, you must declare it as 'global'. Better design would be to return the new value and assign it outside."
    },
    {
        "question_type": "mcq",
        "text": "In game development, what is 'Idempotency' in the context of a Render function?",
        "options": [
            "Calling render twice with the same state should produce the same visual output without side effects",
            "The function should only run once per game",
            "The function should randomly change the board colors",
            "It means the game cannot be played twice"
        ],
        "correct_index": 0,
        "difficulty": "hard",
        "topic_tag": "architecture",
        "explanation": "Pure UI/Render functions should be idempotent; they should reflect the current state perfectly without modifying the state itself."
    },
    {
        "question_type": "mcq",
        "text": "Why is it sometimes better to use 'ANSI escape codes' in a CLI Tic Tac Toe game?",
        "options": [
            "To speed up the Python interpreter",
            "To add colors (Red for X, Blue for O) and clear the screen for a better UX",
            "To encrypt the game data",
            "To allow the game to run on older hardware"
        ],
        "correct_index": 1,
        "difficulty": "medium",
        "topic_tag": "ux-design",
        "explanation": "ANSI codes allow for colored output and screen clearing ('\\033[H\\033[J'), which transforms a basic text log into a professional-feeling app."
    }
]